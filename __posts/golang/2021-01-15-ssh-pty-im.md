---
layout: post
title: "Goè¿›é˜¶52:å¼€å‘æ‰©å±•SSHçš„ä½¿ç”¨é¢†åŸŸå’ŒåŠŸèƒ½"
category: Golang
tags: Goè¿›é˜¶
keywords: 'golang,ssh,sudo'
description: 'ä½œä¸ºä¸€ä¸ªæœåŠ¡ç«¯å¼€å‘,æˆ‘ä»¬èƒ½å¤Ÿåƒä½¿ç”¨é¼ æ ‡ä¸€æ ·ç†Ÿç»ƒä½¿ç”¨SSH,æ¥ç®¡ç†æ§åˆ¶æˆ‘ä»¬çš„æœåŠ¡å™¨.ä½†æ˜¯ä¸è¦æŠŠSSHå±€é™äºæœåŠ¡å™¨ç®¡ç†é¢†åŸŸ,æˆ‘ä»¬è¦æ”¾é£æˆ‘ä»¬çš„å¤§è„‘,æ¥ç»™SSHå¼€ç–†æ‰©åœŸ.è¿™ç¯‡æ–‡ä¸­æˆ‘ä»¬å°†æ‰©å±•SSHçš„åŠŸèƒ½,æˆ‘ä»¬å¯ä»¥ä½¿ç”¨SSHæ¥æŸ¥çœ‹è‚¡ç¥¨ä»·æ ¼,ç¿»è¯‘ä¸€æ®µæ–‡å­—,ç”šè‡³æˆä¸ºä¸€ä¸ªåŠ å¯†èŠå¤©çš„IM'
coverage: ssh_im_coverage.png
permalink: /:categories/:title
date: 2021-01-16T13:04:54+08:00
---

## 1. SSH

ä½œä¸ºä¸€åæœåŠ¡ç«¯å¼€å‘,æ¯å¤©éƒ½ä¼šä½¿ç”¨åˆ°SSHå’Œterminal/console,æˆ‘ä»¬ä»ç¬¬ä¸€æ¬¡æ¥è§¦æœåŠ¡å™¨çš„æ—¶å€™å°±æ¥è§¦äº†SSH.
ä¸‹é¢æ˜¯SSH WIKIçš„å…³äºSSHçš„è§£é‡Š:
> Secure Shellï¼ˆå®‰å…¨å¤–å£³åè®®,ç®€ç§°SSHï¼‰æ˜¯ä¸€ç§åŠ å¯†çš„ç½‘ç»œä¼ è¾“åè®®,å¯åœ¨ä¸å®‰å…¨çš„ç½‘ç»œä¸­ä¸ºç½‘ç»œæœåŠ¡æä¾›å®‰å…¨çš„ä¼ è¾“ç¯å¢ƒ.
> SSHé€šè¿‡åœ¨ç½‘ç»œä¸­åˆ›å»ºå®‰å…¨éš§é“æ¥å®ç°SSHå®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ä¹‹é—´çš„è¿æ¥.è™½ç„¶ä»»ä½•ç½‘ç»œæœåŠ¡éƒ½å¯ä»¥é€šè¿‡SSHå®ç°å®‰å…¨ä¼ è¾“,
> SSHæœ€å¸¸è§çš„ç”¨é€”æ˜¯è¿œç¨‹ç™»å½•ç³»ç»Ÿ,äººä»¬é€šå¸¸åˆ©ç”¨SSHæ¥ä¼ è¾“å‘½ä»¤è¡Œç•Œé¢å’Œè¿œç¨‹æ‰§è¡Œå‘½ä»¤.ä½¿ç”¨é¢‘ç‡æœ€é«˜çš„åœºåˆç±»Unixç³»ç»Ÿ.

æ—¢ç„¶SSHå’ŒHTTP,Websocketä»–ä»¬ä¸€æ ·éƒ½æ˜¯åº”é€šè®¯åè®®,ä¸ºä»€ä¹ˆSSHä»…ä»…å±€é™äºå¯¹æœåŠ¡å™¨è™šæ‹Ÿæœºçš„æ“ä½œç®¡ç†å‘¢?

## 2. SSHå¯ä»¥æ›´å¼ºå¤§

çº¿ä¸Šä½“éªŒLiveDemo `ssh $YOUR_GITHUB_USER_NAME_OR_ANY@mojotv.cn`

æˆ‘ä»¬åç«¯å¼€å‘æ¯å¤©æ¥è§¦æœ€å¤šçš„æ˜¯terminal,æˆ‘ä»¬æ›´åŠ æ“…é•¿ç¼–å†™å‘½ä»¤è¡Œå·¥å…·è€Œä¸æ˜¯GUI.
ç„¶è€ŒSSHå’ŒHTTP,Websocketä»–ä»¬ä¸€æ ·éƒ½æ˜¯é€šè®¯åè®®,ä¸ºä»€ä¹ˆä¸æŠŠæˆ‘ä»¬ç¼–å†™çš„å‘½ä»¤è¡Œå·¥å…·å’ŒSSHèåˆèµ·æ¥,
è¿™æ ·å°±å¯ä»¥è®©æ›´å¤šçš„äººè½»æ¾æ–¹ä¾¿çš„ä½¿ç”¨æˆ‘ä»¬ç¼–å†™çš„Cloudå‘½ä»¤è¡Œå·¥å…·,
ç°åœ¨å°±å¼€å§‹è¡ŒåŠ¨,æˆ‘ä»¬ä¸€èµ·ä½¿ç”¨SSHåè®®æ¥åšä¸€äº›ä¸ä¸€æ ·æœ‰è¶£çš„äº‹æƒ…å§!

è¿™ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å°†å¼€å‘ä¸€ä¸ªSSH-Serverå®ç°ä»¥ä¸‹åŠŸèƒ½:

1. è®©SSH-Serverä½¿ç”¨Github SSH å…¬é’¥ç”¨æˆ·èº«ä»½Authentication.
2. è®©SSH-Serverå®ç°IMèŠå¤©çš„åŠŸèƒ½.
3. è®©SSH-ServeræŸ¥è¯¢è‚¡ç¥¨ä»·æ ¼.
4. è®©SSH-Serveråšæ–‡æœ¬ç¿»è¯‘.

å½“ç„¶ä½ å¯ä»¥å®ç°`action hook interface`æ¥å¼€å‘æ›´åŠ å¼ºå¤§çš„åŠŸèƒ½.

![](/assets/image/sshim_action04.png)
![](/assets/image/sshim_action03.png)
![](/assets/image/sshim_action01.png)

## 3. ä»£ç è®¾è®¡

![](/assets/image/ssh_arch.jpg)

RFCæ ‡å‡†å°†SSHæ¶æ„åˆ†æˆä¸‰éƒ¨åˆ†(å¦‚ä¸Šå›¾æ‰€ç¤º):***ä¼ è¾“å±‚åè®®***,***ç”¨æˆ·è®¤è¯åè®®***,***è¿æ¥åè®®***.

1. ***ä¼ è¾“å±‚åè®®SSH Transport Layer Protocol***:å®ƒè´Ÿè´£è®¤è¯æœåŠ¡å™¨,åŠ å¯†æ•°æ®,ç¡®ä¿æ•°æ®å®Œæ•´æ€§,
   è™½ç„¶å®ƒè¿è¡Œåœ¨TCPä¹‹ä¸Š,ä½†å…¶å®å®ƒå¯ä»¥è¿è¡Œåœ¨ä»»æ„å¯é çš„æ•°æ®æµä¹‹ä¸Š;
2. ***ç”¨æˆ·è®¤è¯åè®®SSH User Authentication Protocol***:å®ƒè´Ÿè´£è®¤è¯ä½¿ç”¨è€…æ˜¯å¦æ˜¯sshæœåŠ¡å™¨çš„ç”¨æˆ·,
   Public Key Authenticationç™»é™†sshå°±å°†åœ¨è¿™ä¸€å±‚å®ç°;
3. ***è¿æ¥åè®®SSH Connection Protocol***:å®ƒå°†æŠŠå¤šè·¯(Multiplex)åŠ å¯†çš„é€šé“è½¬æ¢æˆé€»è¾‘ä¸Šçš„Channel.

![](/assets/image/ssh_art_application.gif)
åŒæ—¶SSHåè®®æ¡†æ¶ä¸­è¿˜ä¸ºè®¸å¤šé«˜å±‚çš„ç½‘ç»œå®‰å…¨åº”ç”¨åè®®æä¾›æ‰©å±•çš„æ”¯æŒ.
å®ƒä»¬ä¹‹é—´çš„å±‚æ¬¡å…³ç³»å¯ä»¥ç”¨å¦‚ä¸Šå›¾æ¥è¡¨ç¤º.

æˆ‘ä»¬çš„ä»£ç å°†ä½¿ç”¨100% Golangç¼–å†™,ä¸€ä¸ªäºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶æå®šå…¨éƒ¨å¹³å° (One Golang executable binary rules them all).

é¡¹ç›®ä»£ç ç›®å½•ç»“æ„:

```bash
.
â”œâ”€â”€ action_default.go           //é»˜è®¤å¤„ç†æ¶ˆæ¯hook
â”œâ”€â”€ action_friend_add.go        //æ·»åŠ å¥½å‹hook
â”œâ”€â”€ action_friend_list.go       //æ˜¾ç¤ºå¥½å‹hook
â”œâ”€â”€ action_help.go              //æ˜¾ç¤ºhelp
â”œâ”€â”€ action_interface.go         //å®šä¹‰hook interface plugin
â”œâ”€â”€ action_square.go            //å…¬å…±é¢‘é“èŠå¤©hook
â”œâ”€â”€ action_stock.go             //æ˜¾ç¤ºAè‚¡è‚¡ç¥¨ä»·æ ¼hook
â”œâ”€â”€ action_translate.go         //è‹±æ–‡ç¿»è¯‘ä¸­hook
â”œâ”€â”€ client.go                   //ç”¨æˆ·sessionçŠ¶æ€ç»´æŠ¤
â”œâ”€â”€ client_handle_exec.go       //å¤„ç† ssh è¿œç¨‹æ‰§è¡Œ command,å’Œ SCP
â”œâ”€â”€ client_handle_sftp.go       //å¤„ç† SFTP
â”œâ”€â”€ client_handle_shell.go      //å¤„ç† ssh äº¤äº’shell
â”œâ”€â”€ db.sqlite3                  //sqlite3 æ•°æ®åº“,å¯ä»¥æ›´æ¢å…¶ä»–æ•°æ®åº“
â”œâ”€â”€ hub_interface.go            //ä¸ºå°†æ¥åˆ†å¸ƒæ‰©å±•é¢„ç•™interface,å°†æ¥èŠå¤©æ¶ˆæ¯ä½¿ç”¨MQ Kafka
â”œâ”€â”€ hub_msg_mem.go              //postOffice MQ golang chan å†…å­˜interfaceå®ç°
â”œâ”€â”€ hub_office_mem.go           //postOffice å¥½å‹ç¾¤ç»„å…³ç³»db interfaceå®ç°
â”œâ”€â”€ main.go                     //é¡¹ç›®å…¥å£
â”œâ”€â”€ model_group.go              //æ¨¡å‹:ç¾¤ç»„ ç”¨æˆ·å…³ç³»
â”œâ”€â”€ model_msg.go                //æ¨¡å‹:æ¶ˆæ¯
â”œâ”€â”€ model_user.go               //æ¨¡å‹:ç”¨æˆ· å¥½å‹å…³ç³»
â”œâ”€â”€ sshd_auth.go                //ç”¨æˆ·è®¤è¯åè®®SSH User Authentication Protocol LDAP OAUTH2 google MFA ...
â”œâ”€â”€ sshd_auth_permission.go     //ç”¨æˆ·è®¤è¯ä¹‹åä¿¡æ¯ä¼ é€’
â”œâ”€â”€ sshd_connection_protocol.go //è¿æ¥åè®®SSH Connection Protocol
â”œâ”€â”€ sshd_run.go                 //ä¼ è¾“å±‚åè®®SSH Transport Layer Protocol
â””â”€â”€ util.go                     //å¸®åŠ©function
```

ä»£ç è¯´æ˜:è¿™ä¸ªé¡¹ç›®æ˜¯ä¸€ä¸ªç®€å•çš„Demo,é‡‡ç”¨è¶…çº§æ‰å¹³çš„ä»£ç ç›®å½•ç»“æ„,æ¥ç®€åŒ–ä»£ç é€»è¾‘,å¼€å‘è´Ÿè´£çš„åº”ç”¨ä½ çœ‹æŒ‰ç…§æ–‡ä»¶åç§°çš„å‰ç¼€æ¥æŠŠä»£ç æ‹†åˆ†åˆ°ä¸åŒçš„package.

- `sshd_auth***.go` ç”¨æˆ·è®¤è¯åè®®SSH User Authentication Protocol: sshdç”¨æˆ·è®¤è¯æ ¡éªŒ,å¯ä»¥æ‰©å±• LDAP OAUTH2 google MFA ...ç­‰ç”¨æˆ·ä½“ç³»
- `sshd_run.go`     ä¼ è¾“å±‚åè®®SSH Transport Layer Protocol: main.go mainå‡½æ•°æ‰§è¡Œçš„å…¥å£
- `sshd_connection_protocol.go` è¿æ¥åè®®SSH Connection Protocol ä»£ç å…¥å£
- `client*.go` åº”ç”¨å±‚æ ¸å¿ƒä»£ç å¤„ç†ç”¨æˆ·è®¤è¯ä¹‹åçš„å„ç§é€»è¾‘
- `action_*.go` è‡ªå®šä¹‰Action Hook,å®ç°interface å¯ä»¥å®Œæˆå„ç§åŠŸèƒ½çš„æ‰©å±•
- `hub_*.go` ç”¨æˆ·å…³ç³»ç»´æŠ¤,èŠå¤©è®°å½•,æ•°æ®æ¥æº,å¯ä»¥æ›´æ¢æˆå…¶ä»–çš„DB,å¯ä»¥æŠŠgolang memory channel MQæ›´æ¢æˆkafka... æ¥æ”¯æŒåˆ†å¸ƒå¼ç³»ç»Ÿ
- `model_.go` ç”¨æˆ·å…³ç³»,ç¾¤,èŠå¤©è®°å½•çš„model
- `main.go` æ•´ä¸ªappçš„æ‰§è¡Œå…¥å£

### 3.1 Golang package

```bash
module sshimdemo //SSH-IM-Demo
go 1.15
require (
	github.com/fatih/color v1.10.0   
	github.com/mattn/go-runewidth v0.0.4 // indirect
	github.com/olekukonko/tablewriter v0.0.1 
	golang.org/x/crypto v0.0.0-20201221181555-eec23a3978ad
	golang.org/x/term v0.0.0-20201117132131-f5c789dd3221
	golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2
	gorm.io/driver/sqlite v1.1.4
	gorm.io/gorm v1.20.11
)
```

- `github.com/fatih/color` åœ¨terminalä¸­æ‰“å°è‰²å½©
- `golang.org/x/text` gbk utf8 ç¼–ç è½¬æ¢
- `golang.org/x/term` pty æ¥å¤„ç†ç”¨æˆ·è¾“å…¥è¾“å‡º
- `gorm.io/gorm` SQLæ•°æ®åº“ORM

æ ¸å¿ƒpackage`golang.org/x/crypto/ssh` å®ç°äº†SSHå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨.ä½†æ˜¯æˆ‘ä»¬åœ¨è¿™é‡Œä¸»è¦ä½¿ç”¨ä»–ä»¬çš„serverç«¯å‡½æ•°æ–¹æ³•.
å¦‚æœä½ æƒ³å¼€å‘ä¸€ä¸ªæ›¿ä»£python ansibleçš„Golangè½®å­,ä½ ä¸€å®šä¸ºç”¨åˆ° `golang.org/x/crypto/ssh` çš„å®¢æˆ·ç«¯ä»£ç .

> SSHæ˜¯***ä¼ è¾“å®‰å…¨åè®®***,***èº«ä»½éªŒè¯åè®®***å’Œä¸€ç³»åˆ—***åº”ç”¨ç¨‹åºåè®®***.å®ƒä¸“é—¨å®ç°äº†åº”ç”¨ç¨‹åºçº§åˆ«åè®®æ˜¯***è¿œç¨‹shell***.
> SSHçš„***å¤šè·¯å¤ç”¨multiplexed***ç‰¹æ€§ä¹Ÿæä¾›éœ€è¦çš„å¼€å‘è€….

### 3.2 Golang SSH ä¼ è¾“å±‚åè®®ç¼–ç 

sshd_run.go

```go
package main

import (
	"golang.org/x/crypto/ssh"
	"gorm.io/gorm"
	"log"
	"net"
)

var privateBytes = []byte(`
-----BEGIN OPENSSH PRIVATE KEY-----
...
-----END OPENSSH PRIVATE KEY-----
`) // sshd-server çš„ç§é’¥æ­£å¼

// startSshSvrListen å¯åŠ¨ssh-serveræœåŠ¡ dbæ¥ç®¡ç† ç”¨æˆ·ç™»å½• å’Œ ç”¨æˆ·ç™»å½•æ—¥å¿— å®Œæˆä¸€äº›èŠå¤©çš„åŠŸèƒ½
// è¿™ä¸ªæ–¹æ³•å°†è¢« main.go çš„ mainæ–¹æ³•è°ƒç”¨,ssh-serverçš„å¯åŠ¨å…¥å£
func startSshSvrListen(addr string, db *gorm.DB) {
	//åˆå§‹è¯ ssh-server å®¢æˆ·ç«¯çš„é…ç½®, ç”¨æˆ·è®¤è¯
	config := &ssh.ServerConfig{
		NoClientAuth: false, //å¦‚æœæ˜¯true ssh-severä¸éœ€è¦ç”¨æˆ·è®¤è¯
		MaxAuthTries: 6,     //ç”¨æˆ·è®¤è¯é‡è¯•æ¬¡æ•°
		//PasswordCallback:            authUserMfa(db),       //sshç”¨æˆ·åå¯†ç è®¤è¯ å¯ä»¥æ‰©å±•æˆ  LDAP ... google MFA
		PublicKeyCallback:           authPublicKeysOfGithub(db), //githubç”¨æˆ·sshå…¬é’¥ç™»å½• https://github.com/${githubUserName}.keys  https://github.com/mojocn.keys
		KeyboardInteractiveCallback: authKeyboard(db),           //é”®ç›˜é—®ç­”è¾“å…¥ç”¨æˆ·è®¤è¯ å¯ä»¥æ‰©å±•æˆ  LDAP ... google MFA
		AuthLogCallback:             nil,                        //è®°å½•ç”¨æˆ·ç™»å½•è®¤è¯æ—¥å¿—çš„callback
		ServerVersion:               "",                         //"sshå¯ä»¥æ‰©å±•çš„æ›´å¤šåŠŸèƒ½çš„èŠå¤©æœåŠ¡", ascii string only  //è‡ªå®šä¹‰æœåŠ¡ç«¯çš„ç‰ˆæœ¬ä¿¡æ¯
	}
	// è§£æéœ€è¦ç»™æœåŠ¡ç«¯è®¾ç½®ssh ç§é’¥
	private, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("æ— æ•ˆç§é’¥è¯ä¹¦:", err)
	}
	config.AddHostKey(private)

	//ç›‘å¬socket
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal("å¯åŠ¨socketå¤±è´¥::", err)
	}
	for {
		// å¤„ç†è¿æ¥
		conn, err := listener.Accept()
		if err != nil {
			// handle error
			log.Println(err)
			continue
		}
		// ç”¨æˆ·è®¤è¯åè®®SSH User Authentication Protocol
		// å¼€å§‹å·¥ä½œ
		// å¼€å§‹ handshake ç”¨æˆ·ç™»å½•ä¹‹å‰è¿™é‡Œç”¨æˆ·èº«ä»½è®¤è¯, ssh.NewServerConn ä¼šè°ƒç”¨ä¸Šé¢ PasswordCallback  PublicKeyCallback KeyboardInteractiveCallback ...çš„callback
		// ç”¨æˆ·ç™»å½•æˆä¹‹åéœ€è¦å‘åä¼ é€’çš„å‚æ•°å¯ä»¥ ä» sConn.Permissions ä¸­è·å–
		sConn, chans, reqs, err := ssh.NewServerConn(conn, config)
		if err != nil {
			// handle error
			log.Print(err)
			continue
		}
		//å¤„ç† è¿æ¥åè®®SSH Connection Protocol
		// ç”¨æˆ·handshake è®¤è¯æˆåŠŸ
		// å¼ºåˆ¶å¿…é¡» ä¸¢å¼ƒæœåŠ¡çš„request,é˜²æ­¢è¢«æ”»å‡»
		go ssh.DiscardRequests(reqs)
		// æ ¸å¿ƒ/VIP/MVP å¤„ç†è¿æ¥åè®®SSH Connection Protocol
		go handleChannels(chans, sConn)
	}
}

```

### 3.3 Golang SSH ç”¨æˆ·è®¤è¯åè®®ç¼–ç 

SSHç”¨æˆ·è®¤è¯åè®®æµç¨‹

1. å®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘é€è®¤è¯è¯·æ±‚,è®¤è¯è¯·æ±‚ä¸­åŒ…å«ç”¨æˆ·å,è®¤è¯æ–¹æ³•,ä¸è¯¥è®¤è¯æ–¹æ³•ç›¸å…³çš„å†…å®¹ï¼ˆå¦‚:passwordè®¤è¯æ—¶,å†…å®¹ä¸ºå¯†ç ï¼‰.
2. æœåŠ¡å™¨ç«¯å¯¹å®¢æˆ·ç«¯è¿›è¡Œè®¤è¯,å¦‚æœè®¤è¯å¤±è´¥,åˆ™å‘å®¢æˆ·ç«¯å‘é€è®¤è¯å¤±è´¥æ¶ˆæ¯,å…¶ä¸­åŒ…å«å¯ä»¥å†æ¬¡è®¤è¯çš„æ–¹æ³•åˆ—è¡¨.
3. å®¢æˆ·ç«¯ä»è®¤è¯æ–¹æ³•åˆ—è¡¨ä¸­é€‰å–ä¸€ç§è®¤è¯æ–¹æ³•å†æ¬¡è¿›è¡Œè®¤è¯.
4. è¯¥è¿‡ç¨‹åå¤è¿›è¡Œ,ç›´åˆ°è®¤è¯æˆåŠŸæˆ–è€…è®¤è¯æ¬¡æ•°è¾¾åˆ°ä¸Šé™,æœåŠ¡å™¨å…³é—­è¿æ¥ä¸ºæ­¢.

SSHæä¾›å¤šç§è®¤è¯æ–¹å¼:

1. passwordè®¤è¯:å®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘å‡º passwordè®¤è¯è¯·æ±‚,å°†ç”¨æˆ·åå’Œå¯†ç åŠ å¯†åå‘é€ç»™æœåŠ¡å™¨;æœåŠ¡å™¨å°†è¯¥ä¿¡æ¯è§£å¯†åå¾—åˆ°ç”¨æˆ·åå’Œå¯†ç çš„æ˜æ–‡,ä¸è®¾å¤‡ä¸Šä¿å­˜çš„ç”¨æˆ·åå’Œå¯†ç è¿›è¡Œæ¯”è¾ƒ,å¹¶è¿”å›è®¤è¯æˆåŠŸæˆ–å¤±è´¥çš„æ¶ˆæ¯.
2. publickeyè®¤è¯:é‡‡ç”¨æ•°å­—ç­¾åçš„æ–¹æ³•æ¥è®¤è¯å®¢æˆ·ç«¯.ç›®å‰,è®¾å¤‡ä¸Šå¯ä»¥åˆ©ç”¨RSAå’Œ DSAä¸¤ç§å…¬å…±å¯†é’¥ç®—æ³•å®ç°æ•°å­—ç­¾å.å®¢æˆ·ç«¯å‘é€åŒ…å«ç”¨æˆ·å,å…¬å…±å¯†é’¥å’Œå…¬å…±å¯†é’¥ç®—æ³•çš„ publickey
   è®¤è¯è¯·æ±‚ç»™æœåŠ¡å™¨ç«¯.æœåŠ¡å™¨å¯¹å…¬é’¥è¿›è¡Œåˆæ³•æ€§æ£€æŸ¥,å¦‚æœä¸åˆæ³•,åˆ™ç›´æ¥å‘é€å¤±è´¥æ¶ˆæ¯;å¦åˆ™,æœåŠ¡å™¨åˆ©ç”¨æ•°å­—ç­¾åå¯¹å®¢æˆ·ç«¯è¿›è¡Œè®¤è¯,å¹¶è¿”å›è®¤è¯æˆåŠŸæˆ–å¤±è´¥çš„æ¶ˆæ¯
3. keyboardInteractiveè®¤è¯: å¯åº”å®šä¹‰å¤šç§keyboard-challengeæ¥æç¤ºç”¨æˆ·è¾“å…¥è®¤è¯çš„input.

sshd_auth.go

```go
package main

import (
	"bytes"
	"context"
	"crypto/md5"
	"errors"
	"fmt"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/ssh"
	"gorm.io/gorm"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)
//authPublicKeysOfGithub github.com å…¬é’¥èº«ä»½authentication
func authPublicKeysOfGithub(db *gorm.DB) func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
	return func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
		userName := conn.User()
		err := sshPublicKeysAuthByGithub(userName, key)//ç”¨è¿‡github.com api è·å–ç”¨æˆ·åçš„å…¬é’¥ æ ¡éªŒ
		if err != nil {
			return nil, err
		}
		one := new(User)
		err = db.Where("name = ?", userName).Take(one).Error
		if errors.Is(err, gorm.ErrRecordNotFound) {
			one.Name = userName
			err := db.Save(one).Error
			if err != nil {
				logrus.Error(err)
			}
		}
		return setPermission(one, Fingerprint(key), "github"), nil
	}
}
//authKeyboard ç”¨æˆ·æ™®é€šåŒ¿åç™»å½• è®°å½•ç”¨æˆ·ä¿¡æ¯
func  authKeyboard(db *gorm.DB) func(conn ssh.ConnMetadata, challenge ssh.KeyboardInteractiveChallenge) (*ssh.Permissions, error) {
	return func(conn ssh.ConnMetadata, challenge ssh.KeyboardInteractiveChallenge) (*ssh.Permissions, error) {
		userName := conn.User()
		one := new(User)
		err := db.Where("name = ?", userName).Take(one).Error
		if errors.Is(err, gorm.ErrRecordNotFound) {
			one.Name = userName
			err := db.Save(one).Error
			if err != nil {
				logrus.Error(err)
			}
		}
		return setPermission(one, "", "anon"), nil
	}
}


//Fingerprint è®¡ç®—å…¬é’¥æŒ‡çº¹
func Fingerprint(k ssh.PublicKey) string {
	hash := md5.Sum(k.Marshal())
	r := fmt.Sprintf("% x", hash)
	return strings.Replace(r, " ", ":", -1)
}
//sshPublicKeysAuthByGithub æ¯”è¾ƒgithubçš„å…¬é’¥
func sshPublicKeysAuthByGithub(user string, key ssh.PublicKey) error {
	publicKeys, err := fetchGithubPublicKeys(user)
	if err != nil {
		return err
	}
	for _, pbk := range publicKeys {
		if bytes.Equal(key.Marshal(), pbk.Marshal()) {
			return nil
		}
	}
	return fmt.Errorf("the key is not match any https://github.com/%s.keys", user)
}
//fetchGithubPublicKeys è·å–å½“ç”¨æˆ·åçš„å…¬é’¥
func fetchGithubPublicKeys(githubUser string) ([]ssh.PublicKey, error) {
	keyURL := fmt.Sprintf("https://github.com/%s.keys", githubUser)
	ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*15)
	defer cancelFunc()
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, keyURL, nil)
	if err != nil {
		return nil, err
	}
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		return nil, errors.New("invalid response from github")
	}
	authorizedKeysBytes, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, fmt.Errorf("reading body:%v", err)
	}
	var keys []ssh.PublicKey
	for len(authorizedKeysBytes) > 0 {
		pubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)
		if err != nil {
			return nil, fmt.Errorf("parsing key: %v",err)//errors.Wrap(err, "parsing key")
		}
		keys = append(keys, pubKey)
		authorizedKeysBytes = rest
	}
	return keys, nil
}

```

å› ä¸ºç¯‡å¹…åŸå› ,æºæ–‡ä»¶ä¸­è¿˜æœ‰å…¶ä»–è®¤è¯æ–¹å¼çš„å®ç°.æ³¨é‡Šçš„ä»£ç ä¸­åŒ…å«å®ç° MFAèº«ä»½è®¤è¯,è‡ªå®šä¹‰é”®ç›˜äº¤äº’è¾“å…¥èº«ä»½è®¤çœŸä¿¡æ¯ å’Œ ç”¨æˆ·åå¯†ç ç”¨æˆ·è®¤è¯çš„å®ä¾‹ä»£ç .
è¿™éƒ¨åˆ†ä»£ç å¯ä»¥å¯ä»¥ä½œä¸ºå®ç°å…¶ä»–è®¤è¯æ–¹å¼çš„å‚è€ƒ.

### 3.4 Golang SSH è¿æ¥åè®®ç¼–ç 

åœ¨è®¤è¯å®Œæ¯•å,å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¹‹é—´å°†ä½¿ç”¨SSHè¿æ¥åè®®è¿›è¡Œå®é™…çš„ä»»åŠ¡æ“ä½œ,åŒ…æ‹¬å¼€å¯äº¤äº’å¼çš„ç™»å½•ä¼šè¯,
è¿œç¨‹å‘½ä»¤è°ƒç”¨,TCPè½¬å‘,X11è½¬å‘ç­‰.åœ¨ä¼ è¾“å±‚åè®®ä¹‹ä¸Š,å¯ç”¨è¿æ¥åè®®çš„æ–¹å¼å°±æ˜¯è¯·æ±‚ä¸€ä¸ªservice nameä¸ºssh-connectionæœåŠ¡.

#### 3.4.1 SSH Channelæœºåˆ¶

è¿æ¥åè®®é‡Œçš„æ¯ä¸ªå®é™…åº”ç”¨éƒ½æ˜¯Channel,å„æ–¹éƒ½æœ‰å¯èƒ½æ‰“å¼€Channel,
å¤§é‡çš„Channelå¤ç”¨åŒä¸€ä¸ªConnectionï¼ˆæˆ‘è®¤ä¸ºè¿™é‡ŒæŒ‡çš„Connectionåº”è¯¥æ˜¯ä¸Šæ–‡è¯´çš„ssh-connection serviceï¼‰.
ä¸€ä¸ªChannelè¢«åŒæ–¹ç”¨è‡ªå·±çš„æ•°å­—æ ‡è¯†,æ‰€ä»¥æ¯ç«¯ä¸åŒçš„æ•°å­—å¯èƒ½æŒ‡å‘çš„å¹¶ä¸æ˜¯ç›¸åŒçš„Channel.
å…¶ä»–ä»»ä½•å’ŒChannelç›¸å…³çš„æ¶ˆæ¯éƒ½ä¼šåŒ…å«å¯¹ç«¯çš„Channelæ ‡è¯†.

#### 3.4.2 sshd_connection_protocol.go ä»£ç è§£æ

è¿™éƒ¨åˆ†ä»£ç æ˜¯å¤„ç†SSHè¿æ¥åè®®(SSH Connection Protocol) çš„å…¥å£.

```go
package main

import (
	"fmt"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/ssh"
	"golang.org/x/term"
	"log"
)

func  handleChannels(channels <-chan ssh.NewChannel, sshConn *ssh.ServerConn) {
	user, err := getPermissionUser(sshConn)// è·å–  SSH User Authentication Protocol ä¼ é€’è¿‡æ¥çš„è®¤è¯ç”¨æˆ·ä¿¡æ¯
	if err != nil {
		log.Println(err)
		return
	}
	//åˆ›å»ºsession pty client
	c := NewClient(user, sshConn, postManVar)
	promptString := fmt.Sprintf("[%s] ", user.Name)

	hasShell := false

	for ch := range channels {
		//äº¤äº’Session
		//ä¸€ä¸ªSessionå°±æ˜¯ä¸€ä¸ªè¿œç¨‹çš„ç¨‹åºçš„æ‰§è¡Œ.è¿™ä¸ªç¨‹åºæˆ–è®¸æ˜¯shell,åº”ç”¨ç¨‹åº,ç³»ç»Ÿè°ƒç”¨æˆ–è€…å†…å»ºçš„å­ç³»ç»Ÿ.å®ƒå¯èƒ½æ²¡æœ‰ç»‘å®šåˆ°è™šæ‹Ÿç»ˆç«¯ä¸Š,åˆæˆ–è€…æœ‰æˆ–æ²¡æœ‰æ¶‰åŠåˆ°X11è½¬å‘.åŒæ—¶é—´,å¯ä»¥æœ‰å¤šä¸ªSessionæ­£åœ¨è¢«è¿è¡Œ.
		if t := ch.ChannelType(); t != "session" {
			ch.Reject(ssh.UnknownChannelType, fmt.Sprintf("unknown channel type: %s", t))
			continue
		}

		channel, requests, err := ch.Accept()
		if err != nil {
			log.Printf("Could not accept channel: %v", err)
			continue
		}
		defer channel.Close()

		c.Term = term.NewTerminal(channel, promptString)

		for req := range requests {
			var width, height int
			var ok bool
			switch req.Type {
			case "shell":
				// å¼€å¯äº¤äº’ tty shell
				//ä¸€æ—¦ä¸€ä¸ªSessionè¢«è®¾ç½®å®Œæ¯•,åœ¨è¿œç«¯å°±ä¼šæœ‰ä¸€ä¸ªç¨‹åºè¢«å¯åŠ¨.è¿™ä¸ªç¨‹åºå¯ä»¥æ˜¯ä¸€ä¸ªShell,ä¹Ÿå¯ä»¥æ—¶ä¸€ä¸ªåº”ç”¨ç¨‹åºæˆ–è€…æ˜¯ä¸€ä¸ªæœ‰ç€ç‹¬ç«‹åŸŸåçš„å­ç³»ç»Ÿ.
				if c.Term != nil && !hasShell {
					go c.HandleShell(channel)
					ok = true
					hasShell = true
				}
			case "pty-req"://é€šè¿‡å¦‚ä¸‹æ¶ˆæ¯å¯ä»¥è®©æœåŠ¡å™¨ä¸ºSessionåˆ†é…ä¸€ä¸ªè™šæ‹Ÿç»ˆç«¯
				//å½“å®¢æˆ·ç«¯çš„ç»ˆç«¯çª—å£å¤§å°è¢«æ”¹å˜æ—¶,æˆ–è®¸éœ€è¦å‘é€è¿™ä¸ªæ¶ˆæ¯ç»™æœåŠ¡å™¨.
				width, height, ok = parsePtyRequest(req.Payload)
				if ok {
					err := c.Resize(width, height)
					ok = err == nil
				}
			case "window-change":
				//å®¢æˆ·terminal size æ”¹å˜ client.Term (pty) çš„sizeä¹Ÿéœ€è¦æ”¹å˜,å¦åˆ™consoleè¾“å‡ºä¼šå‡ºç°æ’ç‰ˆé”™è¯¯
				width, height, ok = parseWinchRequest(req.Payload)
				if ok {
					err := c.Resize(width, height)
					ok = err == nil
				}
			case "exec":
				// ssh root@mojotv.cn whoami
				//ä¸€æ—¦ä¸€ä¸ªSessionè¢«è®¾ç½®å®Œæ¯•,åœ¨è¿œç«¯å°±ä¼šæœ‰ä¸€ä¸ªç¨‹åºè¢«å¯åŠ¨.è¿™ä¸ªç¨‹åºå¯ä»¥æ˜¯ä¸€ä¸ªShell,ä¹Ÿå¯ä»¥æ—¶ä¸€ä¸ªåº”ç”¨ç¨‹åºæˆ–è€…æ˜¯ä¸€ä¸ªæœ‰ç€ç‹¬ç«‹åŸŸåçš„å­ç³»ç»Ÿ.
				command, err := c.ParseCommandLine(req)// åè®® req.Payload é‡Œé¢çš„ç”¨æˆ·å‘½ä»¤è¾“å‡º
				if err != nil {
					logrus.Printf("error parsing ssh execMsg: %s\n", err)
					return
				} else {
					ok = true
				}
				//å¼€å§‹æ‰§è¡Œä» whoami è¿œç¨‹shell å‘½ä»¤
				// æ‰§è¡Œå®Œæˆ ç»“æœç›´æ¥è¿”å›
				go c.HandleExec(command, channel)
			case "env":
				//åœ¨shellæˆ–commandè¢«å¼€å§‹æ—¶ä¹‹å,æˆ–è®¸æœ‰ç¯å¢ƒå˜é‡éœ€è¦è¢«ä¼ é€’è¿‡å».ç„¶è€Œåœ¨ç‰¹æƒç¨‹åºé‡Œä¸å—æ§åˆ¶çš„è®¾ç½®ç¯å¢ƒå˜é‡æ˜¯ä¸€ä¸ªå¾ˆæœ‰é£é™©çš„äº‹æƒ…,
				//æ‰€ä»¥è§„èŒƒæ¨èå®ç°ç»´æŠ¤ä¸€ä¸ªå…è®¸è¢«è®¾ç½®çš„ç¯å¢ƒå˜é‡åˆ—è¡¨æˆ–è€…åªæœ‰å½“sshdä¸¢å¼ƒæƒé™åè®¾ç½®ç¯å¢ƒå˜é‡.
				//todo set language i18n
				logrus.Info(string(req.Payload))
			case "subsystem":
				//ä¸€æ—¦ä¸€ä¸ªSessionè¢«è®¾ç½®å®Œæ¯•,åœ¨è¿œç«¯å°±ä¼šæœ‰ä¸€ä¸ªç¨‹åºè¢«å¯åŠ¨.è¿™ä¸ªç¨‹åºå¯ä»¥æ˜¯ä¸€ä¸ªShell,ä¹Ÿå¯ä»¥æ—¶ä¸€ä¸ªåº”ç”¨ç¨‹åºæˆ–è€…æ˜¯ä¸€ä¸ªæœ‰ç€ç‹¬ç«‹åŸŸåçš„å­ç³»ç»Ÿ.
				// å®ç°ä¸€ä¸‹åŠŸèƒ½å¯ä»¥å®ç° sftpåŠŸèƒ½
				//fmt.Fprintf(debugStream, "Subsystem: %s\n", req.Payload[4:])
				if string(req.Payload[4:]) == "sftp" {
					ok = true
					go c.HandleSftp(channel)
				}

			default:
				log.Println(req.Type, string(req.Payload))
			}
			if req.WantReply {
				req.Reply(ok, nil)
			}
		}
	}
}
```

`request type "exec" "subsystem" "env"` è¿™ç¯‡æ–‡ç« å°±ä¸é‡ç‚¹ä»‹ç»äº†,æ„Ÿå…´è¶£è¯·ç›´æ¥æŸ¥çœ‹æºä»£ç .

- `client_handle_exec.go` : å¤„ç†`exec` æ‰§è¡Œ è¿œç¨‹shellå‘½ä»¤å’Œscp
- `client_handle_sftp.go` : å¤„ç†`subsystem` ä¸»è¦å®Œæˆsftpçš„åŠŸèƒ½
  æˆ‘ä»¬åœ¨åé¢å°†é‡ç‚¹ä»‹ç»`client.go` å’Œ `client_handle_shell.go`.

### 3.5 Client Session çŠ¶æ€ç»´æŠ¤

#### 3.5.1 client.go

```go

package main

import (
	"fmt"
	"github.com/fatih/color"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/ssh"
	"golang.org/x/term"
	"time"
)

type Client struct {
	DeviceSessionID string //è®¾å¤‡uuid
	Conn            *ssh.ServerConn
	postman         *PostMam //å¤„ç† ç”¨æˆ·å…³ç³»å’Œ æ¶ˆæ¯msg MQ
	User            *User//å½“å‰ç”¨æˆ·
	selectedFriend  *User//å½“å‰çª—å£é€‰æ‹©çš„å¯¹è¯çš„å¥½å‹ å¯ä»¥æ˜¯nil
	selectedGroup   *Group//å½“å‰çª—å£é€‰æ‹©çš„å¯¹è¯çš„ç¾¤ç»„ å¯ä»¥æ˜¯nil
	Term            *term.Terminal
	termWidth       int
	termHeight      int
}

// NewClient constructs a new client
// 1.è®°å½•client terminalçš„çŠ¶æ€
// 2.å½“å‰ç”¨æˆ·çš„çŠ¶æ€
// 3.æ¶ˆæ¯å‘é€æ¥æ”¶
// 4.å¥½å‹ç¾¤ç»„å…³ç³»ç®¡ç†
// 5.è¯»å–å®¢æˆ·æ®µterminalçš„è¾“å…¥
func NewClient(user *User, conn *ssh.ServerConn, pm *PostMam) *Client {

	return &Client{
		DeviceSessionID: string(conn.SessionID()),
		Conn:            conn,
		postman:         pm,
		User:            user,
		selectedFriend:  nil,
		selectedGroup:   nil,
		Term:            nil,//pty
		termWidth:       0,
		termHeight:      0,
	}
}

// TermWrite å†™å…¥æ¶ˆæ¯åˆ°å½“å¼ºç”¨æˆ·ssh å®¢æˆ·ç«¯
func (c *Client) writeBack(msg string) {
	c.Term.Write([]byte(msg))
}


func (c *Client) PromptHome() {
	c.Term.SetPrompt(fmt.Sprintf("[%s]", "ğŸŒ"))
}
func (c *Client) SetPrompt(s string) {
	c.Term.SetPrompt(fmt.Sprintf("[%s]", s))
}

func (c *Client) Danger(msg string) {
	content := color.RedString("ğŸ”´  %s\r\n", msg)
	c.writeBack(content)
}
func (c *Client) Warning(msg string) {
	content := color.YellowString("ğŸŸ   %s\r\n", msg)
	c.writeBack(content)
}

func (c *Client) Success(msg string) {
	content := color.GreenString("ğŸŸ¢  %s\n", msg)
	c.writeBack(content)
}

func (c *Client) Primary(msg string) {
	content := color.BlueString("ğŸ”µ  %s\r\n", msg)
	c.writeBack(content)
}

func (c *Client) MsgPrivate(msg string) {
	content := color.HiCyanString("ğŸ’¬  %s\r\n", msg)
	c.writeBack(content)
}

func (c *Client) MsgGroup(msg string) {
	content := color.HiYellowString("ğŸ“» %s\r\n", msg)
	c.writeBack(content)
}
func (c *Client) WritePigeonMsg(msg Msg) {
	if msg.GroupID > 0 {
		c.MsgGroup(msg.Content + "\r\n")
	} else {
		c.MsgPrivate(msg.Content + "\r\n")
		return
	}
}


// Resize resizes the client to the given width and height
func (c *Client) Resize(width, height int) error {
	width = 1000000 //
	err := c.Term.SetSize(width, height)
	if err != nil {
		logrus.Errorf("Resize failed: %dx%d", width, height)
		return err
	}
	c.termWidth, c.termHeight = width, height
	return nil
}

func (c *Client) setSessionPrompt() {
	prompt := fmt.Sprintf("[%s]", c.User.Name)
	if c.selectedFriend != nil {
		prompt = fmt.Sprintf("[%s -> %s]", c.User.Name, c.selectedFriend.Name)
	}
	if c.selectedGroup != nil {
		prompt = fmt.Sprintf("[%s IN %s]", c.User.Name, c.selectedGroup.Name)
	}
	c.Term.SetPrompt(prompt)
}
```

#### 3.5.2 client_handle_shell.go

```go
package main

import (
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/ssh"
	"strings"
)

//HandleShell è¿™é‡Œå°†çœŸè¿™çš„å¤„ç†ç”¨æˆ· ssh shell è¾“å…¥
func (c *Client) HandleShell(channel ssh.Channel) {
	defer channel.Close()
	exitChan := make(chan bool, 1)
	//c.Server.Add(c)
	// ç”¨æˆ·è¿›å…¥èŠå¤©ç•Œé¢ å¼€å§‹æ³¨å†Œç”¨æˆ·åœ¨çº¿çŠ¶æ€, èŠå¤©æ¶ˆæ¯çš„é˜Ÿåˆ—
	err := c.postman.RegisterClientDevice(c.User, c.DeviceSessionID)
	if err != nil {
		logrus.Println(err)
		return
	}
	go func() {
		// Block until done, then remove.
		c.Conn.Wait()
		c.closed = true
		//c.Server.Remove(c)
		//close(c.Messages)
		//c.postman.UserOffline(c.User)  // ç”¨æˆ·ç¦»çº¿
	}()

	go func() {
		//todo:: send history msg

		// æ¥å—å…¶ä»–ç”¨æˆ·å‘é€ç»™ä½ çš„æ¶ˆæ¯ æˆ– å¹¿æ’­æ¶ˆæ¯
		c.postman.ReceiveMsgLoop(c.DeviceSessionID, c, exitChan)
	}()
	new(actionHelp).Exec(c,nil) //è¾“å‡ºå¸®åŠ©ä¿¡æ¯
	for {
		line, err := c.Term.ReadLine()
		if err != nil {
			break
		}
		// ä½¿ç”¨ é»˜è®¤çš„ hook action æ¥å¤„ç† äº¤äº’shellçš„é”®ç›˜è¾“å…¥(èŠå¤© æˆ–è€… æŒ‡ä»¤)
		var doer ActionDoer = new(ActionDefault)
		// choose action
		isCmd, action, args := parseInputLine(line) // è§£æç”¨æˆ·è¾“å…¥ return æ˜¯å¦æ˜¯æŒ‡ä»¤ or æ˜¯å‘é€èŠå¤©æ¶ˆæ¯
		if isCmd {
			v, ok := ActionMap[action] //å¼€å§‹åŒ¹é…æŒ‡ä»¤ æœ‰ç‚¹ç±»ä¼¼ä¸ginä¸­çš„è·¯ç”±åŒ¹é…
			if ok {
				doer = v // åŒ¹é…æŒ‡ä»¤çš„ hook
			} else {
				c.Danger("æœªçŸ¥åŠ¨ä½œæŒ‡ä»¤: " + line)
				continue
			}
		}
		//
		if hint := doer.Hint(args); hint != "" { //å‚æ•°æ£€æŸ¥
			c.Warning("Invalid command: " + line)
			continue
		}
		err = doer.Exec(c, args) // æ‰§è¡Œè‡ªå®šä¹‰çš„action hook
		if err != nil {
			c.Warning(err.Error())
			logrus.Error(err)
			//c.TermWrite(err.Error())
		}
	}

}
//parseInputLine è§£æinput
func parseInputLine(line string) (isCmd bool, action string, args []string) {
	parts := strings.Split(line, " ")
	if len(parts) > 0 && strings.HasPrefix(parts[0], "/") {
		args = []string{}
		for _, p := range parts {
			if t := strings.TrimSpace(p); t != "" {
				args = append(args, t)
			}
		}
		return true, strings.TrimPrefix(args[0], "/"), args
	}
	return false, "", []string{line}
}

```

### 3.6 Hook æ‰©å±•åŠŸèƒ½

ä½ åªéœ€è¦ç¼–å†™å®ç°ä¸€ä¸‹interfaceçš„methodå¹¶åœ¨ `init`å‡½æ•° `registerAction` å°±å¯ä»¥å®Œæˆhookçš„å®Œæˆä½ å¼€å‘çš„æ‰©å±•.

action_interface.go

```go
package main

import "log"


var ActionMap = map[string]ActionDoer{}

//ActionDoer ç¼–å†™æ’ä»¶hook æ¥æ‰©å±•æ›´å¤šçš„åŠŸèƒ½
type ActionDoer interface {
	Help() (alias, long string) //å‘½ä»¤æ‰©å±•çš„å¸®åŠ©ä¿¡æ¯
	Hint(args []string) string //exec ä¹‹å‰çš„å‚æ•°æ£€æŸ¥
	Exec(c *Client, args []string) error //æ‰©å±•çš„æ‰§è¡Œé€»è¾‘
}

//registerAction æ³¨å†Œç¼–å†™çš„action hook æ‰©å±•åŠŸèƒ½,è¿™ä¸ªæ–¹æ³•å»ºè®®åœ¨ init å‡½æ•°ä¸­è°ƒç”¨
func registerAction(name string, doer ActionDoer) {
	_, ok := ActionMap[name]
	if ok {
		log.Fatal("action has already existed: ", name)
	} else {
		ActionMap[name] = doer
	}
}

```

### 3.7 Hook:IMèŠå¤©åŠŸèƒ½

- `action_default.go` å¤„ç†é»˜è®¤èŠå¤©æˆ–å‘½ä»¤æ“ä½œ
- `action_friend_add.go` æ·»åŠ å¥½å‹
- `action_friend_list.go` æ˜¾ç¤ºå¥½å‹å’Œé€‰æ‹©å¥½å‹å¯¹è¯
- `action_default.go` å‘é€æ¶ˆæ¯ç»™å¥½å‹æˆ–è€…ç»™ç¾¤ç»„
- `action_square.go` å¹¿åœºå…¬å…±èŠå¤©

å½“ç„¶ä»¥ä¸ŠèŠå¤©åŠŸèƒ½ç¦»ä¸å¼€ PostOffice interface å®ç°çš„ç”¨æˆ·å…³ç³»ç®¡ç†å’ŒMQæ¶ˆæ¯é˜Ÿåˆ—.
ç”±äºä»¥ä¸Šä»£ç è¿‡äºå¤šè¿™é‡Œä¸åšè¿‡å¤šè§£è¯».è¯·è¯¦ç»†æŸ¥çœ‹æºä»£ç .

![](/assets/image/sshim_action01.png)
![](/assets/image/sshim_action02.png)

### 3.8 Hook:Aè‚¡è‚¡ç¥¨ä»·æ ¼

```go
package main

import (
	"bytes"
	"fmt"
	"github.com/olekukonko/tablewriter" //åœ¨terminalä¸­æ‰“å°å‡ºæ¼‚äº®çš„è¡¨æ ¼
	"golang.org/x/text/encoding/simplifiedchinese"
	"golang.org/x/text/transform"
	"io/ioutil"
	"net/http"
	"strings"
)

func init() {
	registerAction("stock", new(ActionStock))
}

type ActionStock struct{}

func (a ActionStock) Help() (alias, log string) {
	return "stock", "è¾“å…¥è‚¡ç¥¨ä»£ç æŸ¥è¯¢è‚¡ç¥¨ä»·æ ¼ eg: /stock sh688111 sh600036 sz002594"
}
func (a ActionStock) Exec(c *Client, args []string) error {
	var headers []string
	for _, v := range template {
		headers = append(headers, v.Desc)
	}
	table := tablewriter.NewWriter(c.Term)
	//è®¾ç½®è¡¨æ ¼æ ·å¼
	table.SetHeader(headers)
	table.SetBorder(true)
	table.SetHeaderColor(
		tablewriter.Colors{tablewriter.FgHiBlueColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgWhiteColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgCyanColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgHiRedColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgMagentaColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgGreenColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgYellowColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgYellowColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgYellowColor, tablewriter.Bold},
		tablewriter.Colors{tablewriter.FgYellowColor, tablewriter.Bold},

	)
	table.SetColumnColor(
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgHiBlueColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgWhiteColor},

		tablewriter.Colors{tablewriter.Normal, tablewriter.FgCyanColor},
		tablewriter.Colors{tablewriter.Bold, tablewriter.FgHiRedColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgMagentaColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgGreenColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgYellowColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgYellowColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgYellowColor},
		tablewriter.Colors{tablewriter.Normal, tablewriter.FgYellowColor},
	)
	var err error
	for _,code :=range args[1:]{
		row, err2 := stockPrice(code)//sina api è·å–è‚¡ç¥¨ä»·æ ¼
		if err2 != nil {
			err = err2
		}
		table.Append(row)// æ’å…¥è‚¡ç¥¨ä¿¡æ¯åˆ°è¡¨æ ¼
	}
	table.Render()
	table = nil
	return err
}

func (a ActionStock) Hint(args []string) string {
	return ""
}

var template = []StockItem{
	{
		Idx:   0,
		Desc:  "Name",
		Value: "",
	},
	{
		Idx:   1,
		Desc:  "Today_Start_Price",
		Value: "",
	},
	{
		Idx:   2,
		Desc:  "Yesterday_End_Price",
		Value: "",
	},
	{
		Idx:   3,
		Desc:  "Current_Price",
		Value: "",
	},
	{
		Idx:   4,
		Desc:  "Today_Top",
		Value: "",
	},
	{
		Idx:   5,
		Desc:  "Today_Bottom",
		Value: "",
	},
	{
		Idx:   6,
		Desc:  "Buy_One",
		Value: "",
	},
	{
		Idx:   7,
		Desc:  "Sell_One",
		Value: "",
	},
	{
		Idx:   8,
		Desc:  "Deal_Amount",
		Value: "",
	},
	{
		Idx:   9,
		Desc:  "Deal_Money",
		Value: "",
	},
}

type StockItem struct {
	Idx   int
	Desc  string
	Value string
}


func GbkToUtf8(s []byte) ([]byte, error) {
	reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
	d, e := ioutil.ReadAll(reader)
	if e != nil {
		return nil, e
	}
	return d, nil
}

func Utf8ToGbk(s []byte) ([]byte, error) {
	reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewEncoder())
	d, e := ioutil.ReadAll(reader)
	if e != nil {
		return nil, e
	}
	return d, nil
}


func stockPrice(stockCode string) (list []string, err error) {
	url := fmt.Sprintf("http://hq.sinajs.cn/list=%s", stockCode)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	bs, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	utf8, err := GbkToUtf8(bs)
	if err != nil {
		return nil, err
	}
	parts := strings.Split(string(utf8), `="`)
	body := parts[1]

	ps := strings.Split(body, ",")

	for _, v := range template {
		list = append(list, ps[v.Idx])
	}

	return

}

```

![](/assets/image/sshim_action01.png)

## 4 build & run

çº¿ä¸Šä½“éªŒLiveDemo `ssh $YOUR_GITHUB_USER_NAME_OR_ANY@mojotv.cn`

é˜²æ­¢sshd mojotv.cnè¢«åŠ«æŒ,è¯·ç¡®ä¿ä¸€ä¸‹RSAå¯†é’¥æŒ‡çº¹ä¿¡æ¯å¦‚ä¸‹.

```bash
The authenticity of host 'mojotv.cn (39.106.87.48)' can't be established.
RSA key fingerprint is SHA256:QLNi0/fJsotNS++3b4vqiKyAMl5mAz/xkorB7aCIuFQ.
```

![](/assets/image/sshim_action04.png)

local development: æ‰§è¡Œ `go run main.go`  åœ¨ä½ çš„ç»ˆç«¯ä¸­è¾“å…¥ `ssh -p 2222 $YOUR_GITHUB_USER_NAME_OR_ANY@localhost`

![](/assets/image/sshim_action02.png)
![](/assets/image/sshim_action03.png)

## 5. å‚è€ƒèµ„æ–™

- The Secure Shell (SSH) Protocol Architecture  https://tools.ietf.org/html/rfc4251
- The Secure Shell (SSH) Authentication Protocol https://tools.ietf.org/html/rfc4252
- The Secure Shell (SSH) Transport Layer Protocol https://tools.ietf.org/html/rfc4253
- The Secure Shell (SSH) Connection Protocol https://tools.ietf.org/html/rfc4254
- golang.org/x/crypto/ssh https://pkg.go.dev/golang.org/x/crypto/ssh
- [Goè¿›é˜¶35:Goè¯­è¨€è‡ªå®šä¹‰è‡ªå·±çš„SSH-Server](/go/create-your-own-ssh-server)
- [golang-ssh-01:æ‰§è¡Œè¿œç¨‹å‘½ä»¤](/2019/05/22/golang-ssh-session)
- Live Demo `ssh eric@mojotv.cn` `ssh felix@mojotv.cn`